// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: admin.sql

package repository

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const adminGetPlatformStats = `-- name: AdminGetPlatformStats :one
SELECT
    (SELECT COUNT(*) FROM users) as total_users,
    (SELECT COUNT(*) FROM users WHERE created_at >= date_trunc('month', NOW())) as new_users_this_month,
    (SELECT COUNT(*) FROM inspections) as total_inspections,
    (SELECT COUNT(*) FROM inspections WHERE created_at >= date_trunc('month', NOW())) as inspections_this_month,
    (SELECT COUNT(*) FROM reports) as total_reports,
    (SELECT COUNT(*) FROM reports WHERE created_at >= date_trunc('month', NOW())) as reports_this_month,
    (SELECT COALESCE(SUM(cost_cents), 0) FROM ai_usage) as total_ai_cost_cents,
    (SELECT COALESCE(SUM(cost_cents), 0) FROM ai_usage WHERE created_at >= date_trunc('month', NOW())) as ai_cost_this_month_cents
`

type AdminGetPlatformStatsRow struct {
	TotalUsers           int64       `json:"total_users"`
	NewUsersThisMonth    int64       `json:"new_users_this_month"`
	TotalInspections     int64       `json:"total_inspections"`
	InspectionsThisMonth int64       `json:"inspections_this_month"`
	TotalReports         int64       `json:"total_reports"`
	ReportsThisMonth     int64       `json:"reports_this_month"`
	TotalAiCostCents     interface{} `json:"total_ai_cost_cents"`
	AiCostThisMonthCents interface{} `json:"ai_cost_this_month_cents"`
}

// Get platform-wide statistics for admin dashboard
func (q *Queries) AdminGetPlatformStats(ctx context.Context) (AdminGetPlatformStatsRow, error) {
	row := q.db.QueryRowContext(ctx, adminGetPlatformStats)
	var i AdminGetPlatformStatsRow
	err := row.Scan(
		&i.TotalUsers,
		&i.NewUsersThisMonth,
		&i.TotalInspections,
		&i.InspectionsThisMonth,
		&i.TotalReports,
		&i.ReportsThisMonth,
		&i.TotalAiCostCents,
		&i.AiCostThisMonthCents,
	)
	return i, err
}

const adminGetRecentSignups = `-- name: AdminGetRecentSignups :many
SELECT id, email, name, subscription_status, email_verified, created_at
FROM users
ORDER BY created_at DESC
LIMIT $1
`

type AdminGetRecentSignupsRow struct {
	ID                 uuid.UUID      `json:"id"`
	Email              string         `json:"email"`
	Name               string         `json:"name"`
	SubscriptionStatus sql.NullString `json:"subscription_status"`
	EmailVerified      sql.NullBool   `json:"email_verified"`
	CreatedAt          sql.NullTime   `json:"created_at"`
}

// Get recent user signups for admin dashboard
func (q *Queries) AdminGetRecentSignups(ctx context.Context, limit int32) ([]AdminGetRecentSignupsRow, error) {
	rows, err := q.db.QueryContext(ctx, adminGetRecentSignups, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminGetRecentSignupsRow{}
	for rows.Next() {
		var i AdminGetRecentSignupsRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.SubscriptionStatus,
			&i.EmailVerified,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminGetUserAIUsageHistory = `-- name: AdminGetUserAIUsageHistory :many
SELECT
    id,
    model,
    input_tokens,
    output_tokens,
    cost_cents,
    request_type,
    created_at
FROM ai_usage
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2
`

type AdminGetUserAIUsageHistoryParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int32     `json:"limit"`
}

type AdminGetUserAIUsageHistoryRow struct {
	ID           uuid.UUID    `json:"id"`
	Model        string       `json:"model"`
	InputTokens  int32        `json:"input_tokens"`
	OutputTokens int32        `json:"output_tokens"`
	CostCents    int32        `json:"cost_cents"`
	RequestType  string       `json:"request_type"`
	CreatedAt    sql.NullTime `json:"created_at"`
}

// Get AI usage history for a specific user
func (q *Queries) AdminGetUserAIUsageHistory(ctx context.Context, arg AdminGetUserAIUsageHistoryParams) ([]AdminGetUserAIUsageHistoryRow, error) {
	rows, err := q.db.QueryContext(ctx, adminGetUserAIUsageHistory, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminGetUserAIUsageHistoryRow{}
	for rows.Next() {
		var i AdminGetUserAIUsageHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.Model,
			&i.InputTokens,
			&i.OutputTokens,
			&i.CostCents,
			&i.RequestType,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminGetUserByID = `-- name: AdminGetUserByID :one
SELECT
    u.id, u.email, u.password_hash, u.name, u.company_name, u.phone, u.stripe_customer_id, u.subscription_status, u.subscription_tier, u.subscription_id, u.email_verified, u.email_verified_at, u.created_at, u.updated_at, u.business_name, u.business_email, u.business_phone, u.business_address_line1, u.business_address_line2, u.business_city, u.business_state, u.business_postal_code, u.business_license_number, u.business_logo_url,
    COALESCE(SUM(a.input_tokens), 0)::bigint as total_input_tokens,
    COALESCE(SUM(a.output_tokens), 0)::bigint as total_output_tokens,
    COALESCE(SUM(a.cost_cents), 0)::bigint as total_cost_cents,
    COUNT(DISTINCT a.id) as ai_request_count,
    COUNT(DISTINCT i.id) as inspection_count,
    COUNT(DISTINCT r.id) as report_count
FROM users u
LEFT JOIN ai_usage a ON u.id = a.user_id
LEFT JOIN inspections i ON u.id = i.user_id
LEFT JOIN reports r ON u.id = r.user_id
WHERE u.id = $1
GROUP BY u.id
`

type AdminGetUserByIDRow struct {
	ID                    uuid.UUID      `json:"id"`
	Email                 string         `json:"email"`
	PasswordHash          string         `json:"password_hash"`
	Name                  string         `json:"name"`
	CompanyName           sql.NullString `json:"company_name"`
	Phone                 sql.NullString `json:"phone"`
	StripeCustomerID      sql.NullString `json:"stripe_customer_id"`
	SubscriptionStatus    sql.NullString `json:"subscription_status"`
	SubscriptionTier      sql.NullString `json:"subscription_tier"`
	SubscriptionID        sql.NullString `json:"subscription_id"`
	EmailVerified         sql.NullBool   `json:"email_verified"`
	EmailVerifiedAt       sql.NullTime   `json:"email_verified_at"`
	CreatedAt             sql.NullTime   `json:"created_at"`
	UpdatedAt             sql.NullTime   `json:"updated_at"`
	BusinessName          sql.NullString `json:"business_name"`
	BusinessEmail         sql.NullString `json:"business_email"`
	BusinessPhone         sql.NullString `json:"business_phone"`
	BusinessAddressLine1  sql.NullString `json:"business_address_line1"`
	BusinessAddressLine2  sql.NullString `json:"business_address_line2"`
	BusinessCity          sql.NullString `json:"business_city"`
	BusinessState         sql.NullString `json:"business_state"`
	BusinessPostalCode    sql.NullString `json:"business_postal_code"`
	BusinessLicenseNumber sql.NullString `json:"business_license_number"`
	BusinessLogoUrl       sql.NullString `json:"business_logo_url"`
	TotalInputTokens      int64          `json:"total_input_tokens"`
	TotalOutputTokens     int64          `json:"total_output_tokens"`
	TotalCostCents        int64          `json:"total_cost_cents"`
	AiRequestCount        int64          `json:"ai_request_count"`
	InspectionCount       int64          `json:"inspection_count"`
	ReportCount           int64          `json:"report_count"`
}

// Get full user details for admin view
func (q *Queries) AdminGetUserByID(ctx context.Context, id uuid.UUID) (AdminGetUserByIDRow, error) {
	row := q.db.QueryRowContext(ctx, adminGetUserByID, id)
	var i AdminGetUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Name,
		&i.CompanyName,
		&i.Phone,
		&i.StripeCustomerID,
		&i.SubscriptionStatus,
		&i.SubscriptionTier,
		&i.SubscriptionID,
		&i.EmailVerified,
		&i.EmailVerifiedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.BusinessName,
		&i.BusinessEmail,
		&i.BusinessPhone,
		&i.BusinessAddressLine1,
		&i.BusinessAddressLine2,
		&i.BusinessCity,
		&i.BusinessState,
		&i.BusinessPostalCode,
		&i.BusinessLicenseNumber,
		&i.BusinessLogoUrl,
		&i.TotalInputTokens,
		&i.TotalOutputTokens,
		&i.TotalCostCents,
		&i.AiRequestCount,
		&i.InspectionCount,
		&i.ReportCount,
	)
	return i, err
}

const adminGetUserInspections = `-- name: AdminGetUserInspections :many
SELECT id, title, status, inspection_date, created_at
FROM inspections
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2
`

type AdminGetUserInspectionsParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int32     `json:"limit"`
}

type AdminGetUserInspectionsRow struct {
	ID             uuid.UUID    `json:"id"`
	Title          string       `json:"title"`
	Status         string       `json:"status"`
	InspectionDate time.Time    `json:"inspection_date"`
	CreatedAt      sql.NullTime `json:"created_at"`
}

// Get inspections for a specific user (admin view)
func (q *Queries) AdminGetUserInspections(ctx context.Context, arg AdminGetUserInspectionsParams) ([]AdminGetUserInspectionsRow, error) {
	rows, err := q.db.QueryContext(ctx, adminGetUserInspections, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminGetUserInspectionsRow{}
	for rows.Next() {
		var i AdminGetUserInspectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Status,
			&i.InspectionDate,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListUsers = `-- name: AdminListUsers :many

SELECT
    u.id,
    u.email,
    u.name,
    u.subscription_status,
    u.subscription_tier,
    u.email_verified,
    u.created_at,
    COALESCE(SUM(a.input_tokens), 0)::bigint as total_input_tokens,
    COALESCE(SUM(a.output_tokens), 0)::bigint as total_output_tokens,
    COALESCE(SUM(a.cost_cents), 0)::bigint as total_cost_cents,
    COUNT(DISTINCT a.id) as ai_request_count,
    COUNT(DISTINCT i.id) as inspection_count
FROM users u
LEFT JOIN ai_usage a ON u.id = a.user_id
LEFT JOIN inspections i ON u.id = i.user_id
GROUP BY u.id
ORDER BY u.created_at DESC
`

type AdminListUsersRow struct {
	ID                 uuid.UUID      `json:"id"`
	Email              string         `json:"email"`
	Name               string         `json:"name"`
	SubscriptionStatus sql.NullString `json:"subscription_status"`
	SubscriptionTier   sql.NullString `json:"subscription_tier"`
	EmailVerified      sql.NullBool   `json:"email_verified"`
	CreatedAt          sql.NullTime   `json:"created_at"`
	TotalInputTokens   int64          `json:"total_input_tokens"`
	TotalOutputTokens  int64          `json:"total_output_tokens"`
	TotalCostCents     int64          `json:"total_cost_cents"`
	AiRequestCount     int64          `json:"ai_request_count"`
	InspectionCount    int64          `json:"inspection_count"`
}

// Admin queries for platform management
// List all users with their AI usage summary for admin dashboard
func (q *Queries) AdminListUsers(ctx context.Context) ([]AdminListUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, adminListUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminListUsersRow{}
	for rows.Next() {
		var i AdminListUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.SubscriptionStatus,
			&i.SubscriptionTier,
			&i.EmailVerified,
			&i.CreatedAt,
			&i.TotalInputTokens,
			&i.TotalOutputTokens,
			&i.TotalCostCents,
			&i.AiRequestCount,
			&i.InspectionCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminUpdateUserDisabled = `-- name: AdminUpdateUserDisabled :exec
UPDATE users
SET updated_at = NOW()
WHERE id = $1
`

// Enable or disable a user account
func (q *Queries) AdminUpdateUserDisabled(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, adminUpdateUserDisabled, id)
	return err
}
