// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: regulations.sql

package repository

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createRegulation = `-- name: CreateRegulation :one
INSERT INTO regulations (
    standard_number,
    title,
    category,
    subcategory,
    full_text,
    summary,
    severity_typical,
    parent_standard,
    effective_date,
    last_updated
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
RETURNING id, standard_number, title, category, subcategory, full_text, summary, severity_typical, parent_standard, effective_date, last_updated, search_vector, created_at, updated_at
`

type CreateRegulationParams struct {
	StandardNumber  string         `json:"standard_number"`
	Title           string         `json:"title"`
	Category        string         `json:"category"`
	Subcategory     sql.NullString `json:"subcategory"`
	FullText        string         `json:"full_text"`
	Summary         sql.NullString `json:"summary"`
	SeverityTypical sql.NullString `json:"severity_typical"`
	ParentStandard  sql.NullString `json:"parent_standard"`
	EffectiveDate   sql.NullTime   `json:"effective_date"`
	LastUpdated     sql.NullTime   `json:"last_updated"`
}

func (q *Queries) CreateRegulation(ctx context.Context, arg CreateRegulationParams) (Regulation, error) {
	row := q.db.QueryRowContext(ctx, createRegulation,
		arg.StandardNumber,
		arg.Title,
		arg.Category,
		arg.Subcategory,
		arg.FullText,
		arg.Summary,
		arg.SeverityTypical,
		arg.ParentStandard,
		arg.EffectiveDate,
		arg.LastUpdated,
	)
	var i Regulation
	err := row.Scan(
		&i.ID,
		&i.StandardNumber,
		&i.Title,
		&i.Category,
		&i.Subcategory,
		&i.FullText,
		&i.Summary,
		&i.SeverityTypical,
		&i.ParentStandard,
		&i.EffectiveDate,
		&i.LastUpdated,
		&i.SearchVector,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRegulationByID = `-- name: GetRegulationByID :one
SELECT id, standard_number, title, category, subcategory, full_text, summary, severity_typical, parent_standard, effective_date, last_updated, search_vector, created_at, updated_at FROM regulations
WHERE id = $1
`

func (q *Queries) GetRegulationByID(ctx context.Context, id uuid.UUID) (Regulation, error) {
	row := q.db.QueryRowContext(ctx, getRegulationByID, id)
	var i Regulation
	err := row.Scan(
		&i.ID,
		&i.StandardNumber,
		&i.Title,
		&i.Category,
		&i.Subcategory,
		&i.FullText,
		&i.Summary,
		&i.SeverityTypical,
		&i.ParentStandard,
		&i.EffectiveDate,
		&i.LastUpdated,
		&i.SearchVector,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRegulationByStandardNumber = `-- name: GetRegulationByStandardNumber :one
SELECT id, standard_number, title, category, subcategory, full_text, summary, severity_typical, parent_standard, effective_date, last_updated, search_vector, created_at, updated_at FROM regulations
WHERE standard_number = $1
`

func (q *Queries) GetRegulationByStandardNumber(ctx context.Context, standardNumber string) (Regulation, error) {
	row := q.db.QueryRowContext(ctx, getRegulationByStandardNumber, standardNumber)
	var i Regulation
	err := row.Scan(
		&i.ID,
		&i.StandardNumber,
		&i.Title,
		&i.Category,
		&i.Subcategory,
		&i.FullText,
		&i.Summary,
		&i.SeverityTypical,
		&i.ParentStandard,
		&i.EffectiveDate,
		&i.LastUpdated,
		&i.SearchVector,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listRegulationsByCategory = `-- name: ListRegulationsByCategory :many
SELECT id, standard_number, title, category, subcategory, full_text, summary, severity_typical, parent_standard, effective_date, last_updated, search_vector, created_at, updated_at FROM regulations
WHERE category = $1
AND ($2::text IS NULL OR subcategory = $2)
ORDER BY standard_number ASC
`

type ListRegulationsByCategoryParams struct {
	Category    string         `json:"category"`
	Subcategory sql.NullString `json:"subcategory"`
}

func (q *Queries) ListRegulationsByCategory(ctx context.Context, arg ListRegulationsByCategoryParams) ([]Regulation, error) {
	rows, err := q.db.QueryContext(ctx, listRegulationsByCategory, arg.Category, arg.Subcategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Regulation{}
	for rows.Next() {
		var i Regulation
		if err := rows.Scan(
			&i.ID,
			&i.StandardNumber,
			&i.Title,
			&i.Category,
			&i.Subcategory,
			&i.FullText,
			&i.Summary,
			&i.SeverityTypical,
			&i.ParentStandard,
			&i.EffectiveDate,
			&i.LastUpdated,
			&i.SearchVector,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchRegulations = `-- name: SearchRegulations :many
SELECT id, standard_number, title, category, subcategory, full_text, summary, severity_typical, parent_standard, effective_date, last_updated, search_vector, created_at, updated_at,
    ts_rank(search_vector, websearch_to_tsquery('english', $1)) as rank
FROM regulations
WHERE search_vector @@ websearch_to_tsquery('english', $1)
ORDER BY rank DESC, standard_number ASC
LIMIT $2
`

type SearchRegulationsParams struct {
	WebsearchToTsquery string `json:"websearch_to_tsquery"`
	Limit              int32  `json:"limit"`
}

type SearchRegulationsRow struct {
	ID              uuid.UUID      `json:"id"`
	StandardNumber  string         `json:"standard_number"`
	Title           string         `json:"title"`
	Category        string         `json:"category"`
	Subcategory     sql.NullString `json:"subcategory"`
	FullText        string         `json:"full_text"`
	Summary         sql.NullString `json:"summary"`
	SeverityTypical sql.NullString `json:"severity_typical"`
	ParentStandard  sql.NullString `json:"parent_standard"`
	EffectiveDate   sql.NullTime   `json:"effective_date"`
	LastUpdated     sql.NullTime   `json:"last_updated"`
	SearchVector    interface{}    `json:"search_vector"`
	CreatedAt       sql.NullTime   `json:"created_at"`
	UpdatedAt       sql.NullTime   `json:"updated_at"`
	Rank            float32        `json:"rank"`
}

func (q *Queries) SearchRegulations(ctx context.Context, arg SearchRegulationsParams) ([]SearchRegulationsRow, error) {
	rows, err := q.db.QueryContext(ctx, searchRegulations, arg.WebsearchToTsquery, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchRegulationsRow{}
	for rows.Next() {
		var i SearchRegulationsRow
		if err := rows.Scan(
			&i.ID,
			&i.StandardNumber,
			&i.Title,
			&i.Category,
			&i.Subcategory,
			&i.FullText,
			&i.Summary,
			&i.SeverityTypical,
			&i.ParentStandard,
			&i.EffectiveDate,
			&i.LastUpdated,
			&i.SearchVector,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
