// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: jobs.sql

package repository

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const deleteCompletedJobsOlderThan = `-- name: DeleteCompletedJobsOlderThan :exec
DELETE FROM jobs
WHERE status = 'completed'
AND completed_at < $1
`

func (q *Queries) DeleteCompletedJobsOlderThan(ctx context.Context, completedAt sql.NullTime) error {
	_, err := q.db.ExecContext(ctx, deleteCompletedJobsOlderThan, completedAt)
	return err
}

const dequeueJob = `-- name: DequeueJob :one
SELECT id, job_type, payload, status, priority, attempts, max_attempts, scheduled_at, started_at, completed_at, error_message, created_at FROM jobs
WHERE status = 'pending'
AND scheduled_at <= NOW()
ORDER BY priority DESC, scheduled_at ASC
LIMIT 1
FOR UPDATE SKIP LOCKED
`

func (q *Queries) DequeueJob(ctx context.Context) (Job, error) {
	row := q.db.QueryRowContext(ctx, dequeueJob)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.JobType,
		&i.Payload,
		&i.Status,
		&i.Priority,
		&i.Attempts,
		&i.MaxAttempts,
		&i.ScheduledAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.ErrorMessage,
		&i.CreatedAt,
	)
	return i, err
}

const enqueueJob = `-- name: EnqueueJob :one
INSERT INTO jobs (
    job_type,
    payload,
    priority,
    max_attempts,
    scheduled_at
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, job_type, payload, status, priority, attempts, max_attempts, scheduled_at, started_at, completed_at, error_message, created_at
`

type EnqueueJobParams struct {
	JobType     string          `json:"job_type"`
	Payload     json.RawMessage `json:"payload"`
	Priority    int32           `json:"priority"`
	MaxAttempts int32           `json:"max_attempts"`
	ScheduledAt time.Time       `json:"scheduled_at"`
}

func (q *Queries) EnqueueJob(ctx context.Context, arg EnqueueJobParams) (Job, error) {
	row := q.db.QueryRowContext(ctx, enqueueJob,
		arg.JobType,
		arg.Payload,
		arg.Priority,
		arg.MaxAttempts,
		arg.ScheduledAt,
	)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.JobType,
		&i.Payload,
		&i.Status,
		&i.Priority,
		&i.Attempts,
		&i.MaxAttempts,
		&i.ScheduledAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.ErrorMessage,
		&i.CreatedAt,
	)
	return i, err
}

const getJobByID = `-- name: GetJobByID :one
SELECT id, job_type, payload, status, priority, attempts, max_attempts, scheduled_at, started_at, completed_at, error_message, created_at FROM jobs
WHERE id = $1
`

func (q *Queries) GetJobByID(ctx context.Context, id uuid.UUID) (Job, error) {
	row := q.db.QueryRowContext(ctx, getJobByID, id)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.JobType,
		&i.Payload,
		&i.Status,
		&i.Priority,
		&i.Attempts,
		&i.MaxAttempts,
		&i.ScheduledAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.ErrorMessage,
		&i.CreatedAt,
	)
	return i, err
}

const recoverStaleJobs = `-- name: RecoverStaleJobs :execrows
UPDATE jobs
SET status = 'pending',
    error_message = 'Job timed out - worker may have crashed'
WHERE status = 'running'
AND started_at < NOW() - make_interval(secs => $1)
`

// Recovers jobs that have been running too long (worker may have crashed)
// $1 is the threshold in seconds (e.g., 600 for 10 minutes)
func (q *Queries) RecoverStaleJobs(ctx context.Context, secs float64) (int64, error) {
	result, err := q.db.ExecContext(ctx, recoverStaleJobs, secs)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateJobCompleted = `-- name: UpdateJobCompleted :exec
UPDATE jobs
SET status = 'completed',
    completed_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateJobCompleted(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, updateJobCompleted, id)
	return err
}

const updateJobFailed = `-- name: UpdateJobFailed :exec
UPDATE jobs
SET status = CASE
    WHEN attempts >= max_attempts THEN 'failed'
    ELSE 'pending'
END,
error_message = $2,
scheduled_at = CASE
    WHEN attempts < max_attempts THEN NOW() + (LEAST(POWER(2, attempts - 1) * 30, 3600) * INTERVAL '1 second')
    ELSE scheduled_at
END
WHERE id = $1
`

type UpdateJobFailedParams struct {
	ID           uuid.UUID      `json:"id"`
	ErrorMessage sql.NullString `json:"error_message"`
}

// Updates a failed job with exponential backoff (30s * 2^attempts, max 1 hour)
func (q *Queries) UpdateJobFailed(ctx context.Context, arg UpdateJobFailedParams) error {
	_, err := q.db.ExecContext(ctx, updateJobFailed, arg.ID, arg.ErrorMessage)
	return err
}

const updateJobStarted = `-- name: UpdateJobStarted :exec
UPDATE jobs
SET status = 'running',
    started_at = NOW(),
    attempts = attempts + 1
WHERE id = $1
`

func (q *Queries) UpdateJobStarted(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, updateJobStarted, id)
	return err
}
