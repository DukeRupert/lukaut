// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tokens.sql

package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createEmailVerificationToken = `-- name: CreateEmailVerificationToken :one

INSERT INTO email_verification_tokens (
    user_id,
    token_hash,
    expires_at
) VALUES (
    $1, $2, $3
)
RETURNING id, user_id, token_hash, expires_at, created_at
`

type CreateEmailVerificationTokenParams struct {
	UserID    uuid.UUID `json:"user_id"`
	TokenHash string    `json:"token_hash"`
	ExpiresAt time.Time `json:"expires_at"`
}

// =============================================================================
// Email Verification Token Queries
// =============================================================================
// Creates a new email verification token for a user.
// The token_hash should be SHA-256 hash of the raw token (64 char hex).
// The raw token is sent to user via email; only the hash is stored.
//
// Note: Caller should delete existing tokens for user before calling this
// to enforce the one-token-per-user constraint.
func (q *Queries) CreateEmailVerificationToken(ctx context.Context, arg CreateEmailVerificationTokenParams) (EmailVerificationToken, error) {
	row := q.db.QueryRowContext(ctx, createEmailVerificationToken, arg.UserID, arg.TokenHash, arg.ExpiresAt)
	var i EmailVerificationToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const createPasswordResetToken = `-- name: CreatePasswordResetToken :one

INSERT INTO password_reset_tokens (
    user_id,
    token_hash,
    expires_at
) VALUES (
    $1, $2, $3
)
RETURNING id, user_id, token_hash, expires_at, used_at, created_at
`

type CreatePasswordResetTokenParams struct {
	UserID    uuid.UUID `json:"user_id"`
	TokenHash string    `json:"token_hash"`
	ExpiresAt time.Time `json:"expires_at"`
}

// =============================================================================
// Password Reset Token Queries
// =============================================================================
// Creates a new password reset token for a user.
// The token_hash should be SHA-256 hash of the raw token (64 char hex).
// The raw token is sent to user via email; only the hash is stored.
//
// Note: Caller should delete existing tokens for user before calling this
// to enforce the one-token-per-user constraint.
func (q *Queries) CreatePasswordResetToken(ctx context.Context, arg CreatePasswordResetTokenParams) (PasswordResetToken, error) {
	row := q.db.QueryRowContext(ctx, createPasswordResetToken, arg.UserID, arg.TokenHash, arg.ExpiresAt)
	var i PasswordResetToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.ExpiresAt,
		&i.UsedAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteEmailVerificationToken = `-- name: DeleteEmailVerificationToken :exec
DELETE FROM email_verification_tokens
WHERE token_hash = $1
`

// Deletes a specific email verification token by its hash.
// Called after successful email verification.
// Idempotent - no error if token doesn't exist.
func (q *Queries) DeleteEmailVerificationToken(ctx context.Context, tokenHash string) error {
	_, err := q.db.ExecContext(ctx, deleteEmailVerificationToken, tokenHash)
	return err
}

const deleteExpiredEmailVerificationTokens = `-- name: DeleteExpiredEmailVerificationTokens :exec
DELETE FROM email_verification_tokens
WHERE expires_at <= NOW()
`

// Removes all expired email verification tokens.
// Should be called periodically (e.g., daily) as a cleanup task.
func (q *Queries) DeleteExpiredEmailVerificationTokens(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteExpiredEmailVerificationTokens)
	return err
}

const deleteExpiredPasswordResetTokens = `-- name: DeleteExpiredPasswordResetTokens :exec
DELETE FROM password_reset_tokens
WHERE expires_at <= NOW()
AND used_at IS NULL
`

// Removes all expired password reset tokens.
// Should be called periodically (e.g., daily) as a cleanup task.
// Note: This keeps used tokens for audit; remove the AND clause if not needed.
func (q *Queries) DeleteExpiredPasswordResetTokens(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteExpiredPasswordResetTokens)
	return err
}

const deletePasswordResetToken = `-- name: DeletePasswordResetToken :exec
DELETE FROM password_reset_tokens
WHERE token_hash = $1
`

// Deletes a specific password reset token by its hash.
// Alternative to marking as used - use when no audit trail needed.
func (q *Queries) DeletePasswordResetToken(ctx context.Context, tokenHash string) error {
	_, err := q.db.ExecContext(ctx, deletePasswordResetToken, tokenHash)
	return err
}

const deleteUserEmailVerificationTokens = `-- name: DeleteUserEmailVerificationTokens :exec
DELETE FROM email_verification_tokens
WHERE user_id = $1
`

// Deletes all email verification tokens for a specific user.
// Called before creating a new token to ensure one-token-per-user.
// Also useful when user requests a new verification email.
func (q *Queries) DeleteUserEmailVerificationTokens(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUserEmailVerificationTokens, userID)
	return err
}

const deleteUserPasswordResetTokens = `-- name: DeleteUserPasswordResetTokens :exec
DELETE FROM password_reset_tokens
WHERE user_id = $1
`

// Deletes all password reset tokens for a specific user.
// Called before creating a new token to ensure one-token-per-user.
// Also useful when user successfully logs in (no longer needs reset).
func (q *Queries) DeleteUserPasswordResetTokens(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUserPasswordResetTokens, userID)
	return err
}

const getEmailVerificationTokenByHash = `-- name: GetEmailVerificationTokenByHash :one
SELECT id, user_id, token_hash, expires_at, created_at FROM email_verification_tokens
WHERE token_hash = $1
AND expires_at > NOW()
`

// Retrieves a valid (non-expired) email verification token by its hash.
// Returns sql.ErrNoRows if token doesn't exist or is expired.
// Used during the email verification flow when user clicks the link.
func (q *Queries) GetEmailVerificationTokenByHash(ctx context.Context, tokenHash string) (EmailVerificationToken, error) {
	row := q.db.QueryRowContext(ctx, getEmailVerificationTokenByHash, tokenHash)
	var i EmailVerificationToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getEmailVerificationTokenByUserID = `-- name: GetEmailVerificationTokenByUserID :one
SELECT id, user_id, token_hash, expires_at, created_at FROM email_verification_tokens
WHERE user_id = $1
AND expires_at > NOW()
`

// Retrieves the verification token for a specific user.
// Useful to check if user already has a pending verification.
// Note: Only returns non-expired tokens.
func (q *Queries) GetEmailVerificationTokenByUserID(ctx context.Context, userID uuid.UUID) (EmailVerificationToken, error) {
	row := q.db.QueryRowContext(ctx, getEmailVerificationTokenByUserID, userID)
	var i EmailVerificationToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getPasswordResetTokenByHash = `-- name: GetPasswordResetTokenByHash :one
SELECT id, user_id, token_hash, expires_at, used_at, created_at FROM password_reset_tokens
WHERE token_hash = $1
AND expires_at > NOW()
AND used_at IS NULL
`

// Retrieves a valid (non-expired, unused) password reset token by its hash.
// Returns sql.ErrNoRows if token doesn't exist, is expired, or was used.
// Used during the password reset flow when user clicks the link.
func (q *Queries) GetPasswordResetTokenByHash(ctx context.Context, tokenHash string) (PasswordResetToken, error) {
	row := q.db.QueryRowContext(ctx, getPasswordResetTokenByHash, tokenHash)
	var i PasswordResetToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.ExpiresAt,
		&i.UsedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getPasswordResetTokenByUserID = `-- name: GetPasswordResetTokenByUserID :one
SELECT id, user_id, token_hash, expires_at, used_at, created_at FROM password_reset_tokens
WHERE user_id = $1
AND expires_at > NOW()
AND used_at IS NULL
`

// Retrieves the password reset token for a specific user.
// Useful to check if user already has a pending reset request.
// Note: Only returns non-expired, unused tokens.
func (q *Queries) GetPasswordResetTokenByUserID(ctx context.Context, userID uuid.UUID) (PasswordResetToken, error) {
	row := q.db.QueryRowContext(ctx, getPasswordResetTokenByUserID, userID)
	var i PasswordResetToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.ExpiresAt,
		&i.UsedAt,
		&i.CreatedAt,
	)
	return i, err
}

const markPasswordResetTokenUsed = `-- name: MarkPasswordResetTokenUsed :exec
UPDATE password_reset_tokens
SET used_at = NOW()
WHERE token_hash = $1
`

// Marks a password reset token as used after successful password change.
// Sets used_at to current timestamp for audit trail.
// This prevents token reuse while maintaining history.
func (q *Queries) MarkPasswordResetTokenUsed(ctx context.Context, tokenHash string) error {
	_, err := q.db.ExecContext(ctx, markPasswordResetTokenUsed, tokenHash)
	return err
}
