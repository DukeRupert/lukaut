package inspections

import (
	"fmt"

	"github.com/DukeRupert/lukaut/internal/templ/layouts"
	"github.com/DukeRupert/lukaut/internal/templ/partials"
)

// ReviewQueuePage renders the keyboard-driven queue-based review page.
// Uses htmx for navigation and status updates, with minimal Alpine.js for keyboard shortcuts.
templ ReviewQueuePage(data ReviewQueuePageData) {
	@layouts.AppLayout(layouts.AppLayoutData{
		Title:       fmt.Sprintf("Review Violations - %s", data.Inspection.Title),
		CurrentPath: data.CurrentPath,
		User:        userToLayoutUser(data.User),
		CSRFToken:   data.CSRFToken,
		Flash:       data.Flash,
	}) {
		<div x-data="queueKeyboard()" @keydown.window="handleKeydown($event)">
			// Header Bar
			@partials.QueueHeader(partials.QueueHeaderData{
				InspectionID: data.Inspection.ID,
				Position:     data.Position,
				TotalCount:   data.TotalCount,
				Counts: partials.ViolationCounts{
					Total:     data.ViolationCounts.Total,
					Pending:   data.ViolationCounts.Pending,
					Confirmed: data.ViolationCounts.Confirmed,
					Rejected:  data.ViolationCounts.Rejected,
				},
			})
			// Main content area - swapped by htmx
			<div id="queue-content">
				if data.TotalCount == 0 {
					// Empty State
					@partials.QueueEmptyState(data.Inspection.ID)
				} else if data.IsComplete {
					// Completion Screen
					@partials.QueueCompletion(partials.QueueCompletionData{
						InspectionID:   data.Inspection.ID,
						ConfirmedCount: data.ViolationCounts.Confirmed,
						RejectedCount:  data.ViolationCounts.Rejected,
					})
				} else if data.Violation != nil {
					// Single Violation View
					@partials.QueueViolationView(partials.QueueViolationViewData{
						InspectionID: data.Inspection.ID,
						Violation: partials.QueueViolationDisplay{
							ID:             data.Violation.ID,
							Description:    data.Violation.Description,
							AIDescription:  data.Violation.AIDescription,
							Status:         data.Violation.Status,
							Severity:       data.Violation.Severity,
							Confidence:     data.Violation.Confidence,
							InspectorNotes: data.Violation.InspectorNotes,
							ThumbnailURL:   data.Violation.ThumbnailURL,
							OriginalURL:    data.Violation.OriginalURL,
							ImageID:        data.Violation.ImageID,
							Regulations:    violationRegsToQueueRegs(data.Violation.Regulations),
						},
						Position:   data.Position,
						TotalCount: data.TotalCount,
						HasPrev:    data.Position > 0,
						HasNext:    data.Position < data.TotalCount-1,
					})
				}
			</div>
		</div>
		// Keyboard shortcut handler - minimal Alpine.js
		@queueKeyboardScript(data.Inspection.ID)
	}
}

// queueKeyboardScript provides the Alpine.js component for keyboard shortcuts.
// It triggers htmx buttons programmatically rather than managing state.
templ queueKeyboardScript(inspectionID string) {
	<script>
		const queueInspectionID = @templ.Raw(fmt.Sprintf("%q", inspectionID));

		function queueKeyboard() {
			return {
				handleKeydown(e) {
					// Don't handle if in input field (let the edit form handle its own keys)
					if (['INPUT', 'TEXTAREA', 'SELECT'].includes(e.target.tagName)) {
						// Allow Escape to cancel edit
						if (e.key === 'Escape') {
							// Alpine's x-on:keydown.escape on the edit form will handle this
						}
						return;
					}

					// Don't handle with modifier keys
					if (e.metaKey || e.ctrlKey || e.altKey) return;

					switch (e.key.toLowerCase()) {
						case 'a':
							// Accept - click the accept button
							const acceptBtn = document.getElementById('btn-accept');
							if (acceptBtn && !acceptBtn.disabled) {
								acceptBtn.click();
								e.preventDefault();
							}
							break;
						case 'r':
							// Reject - click the reject button
							const rejectBtn = document.getElementById('btn-reject');
							if (rejectBtn && !rejectBtn.disabled) {
								rejectBtn.click();
								e.preventDefault();
							}
							break;
						case 'e':
							// Edit - trigger Alpine edit mode
							// The edit toggle is handled by Alpine within the partial
							// We need to dispatch a custom event or find another way
							// For now, we'll find and click any edit button
							const editBtnContainer = document.querySelector('[x-show="!editing"]');
							if (editBtnContainer) {
								const editBtn = editBtnContainer.querySelector('button[\\@click*="editing"]');
								if (editBtn) {
									editBtn.click();
									e.preventDefault();
								}
							}
							break;
						case 'j':
						case 'arrowright':
							// Next - click the next button
							const nextBtn = document.getElementById('btn-next');
							if (nextBtn && !nextBtn.disabled) {
								nextBtn.click();
								e.preventDefault();
							}
							break;
						case 'k':
						case 'arrowleft':
							// Previous - click the prev button
							const prevBtn = document.getElementById('btn-prev');
							if (prevBtn && !prevBtn.disabled) {
								prevBtn.click();
								e.preventDefault();
							}
							break;
						case 'escape':
							// Exit to inspection page
							window.location.href = '/inspections/' + queueInspectionID;
							e.preventDefault();
							break;
					}
				}
			};
		}
	</script>
}

// Helper function to convert violation regulations to queue format
// This is defined in Go since templ templates can call Go functions
func violationRegsToQueueRegs(regs []ViolationRegulationDisplay) []partials.QueueRegulationDisplay {
	result := make([]partials.QueueRegulationDisplay, len(regs))
	for i, r := range regs {
		result[i] = partials.QueueRegulationDisplay{
			RegulationID:   r.RegulationID,
			StandardNumber: r.StandardNumber,
			Title:          r.Title,
			IsPrimary:      r.IsPrimary,
		}
	}
	return result
}
