// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.977
package inspections

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

import (
	"fmt"

	"github.com/DukeRupert/lukaut/internal/templ/layouts"
	"github.com/DukeRupert/lukaut/internal/templ/partials"
)

// ReviewQueuePage renders the keyboard-driven queue-based review page.
// Uses htmx for navigation and status updates, with minimal Alpine.js for keyboard shortcuts.
func ReviewQueuePage(data ReviewQueuePageData) templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Var2 := templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
			templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
			templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
			if !templ_7745c5c3_IsBuffer {
				defer func() {
					templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
					if templ_7745c5c3_Err == nil {
						templ_7745c5c3_Err = templ_7745c5c3_BufErr
					}
				}()
			}
			ctx = templ.InitializeContext(ctx)
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<div x-data=\"queueKeyboard()\" @keydown.window=\"handleKeydown($event)\">")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = partials.QueueHeader(partials.QueueHeaderData{
				InspectionID: data.Inspection.ID,
				Position:     data.Position,
				TotalCount:   data.TotalCount,
				Counts: partials.ViolationCounts{
					Total:     data.ViolationCounts.Total,
					Pending:   data.ViolationCounts.Pending,
					Confirmed: data.ViolationCounts.Confirmed,
					Rejected:  data.ViolationCounts.Rejected,
				},
			}).Render(ctx, templ_7745c5c3_Buffer)
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 2, "<div id=\"queue-content\">")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			if data.TotalCount == 0 {
				templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 3, " ")
				if templ_7745c5c3_Err != nil {
					return templ_7745c5c3_Err
				}
				templ_7745c5c3_Err = partials.QueueEmptyState(data.Inspection.ID).Render(ctx, templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err != nil {
					return templ_7745c5c3_Err
				}
			} else if data.IsComplete {
				templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 4, " ")
				if templ_7745c5c3_Err != nil {
					return templ_7745c5c3_Err
				}
				templ_7745c5c3_Err = partials.QueueCompletion(partials.QueueCompletionData{
					InspectionID:   data.Inspection.ID,
					ConfirmedCount: data.ViolationCounts.Confirmed,
					RejectedCount:  data.ViolationCounts.Rejected,
				}).Render(ctx, templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err != nil {
					return templ_7745c5c3_Err
				}
			} else if data.Violation != nil {
				templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 5, " ")
				if templ_7745c5c3_Err != nil {
					return templ_7745c5c3_Err
				}
				templ_7745c5c3_Err = partials.QueueViolationView(partials.QueueViolationViewData{
					InspectionID: data.Inspection.ID,
					Violation: partials.QueueViolationDisplay{
						ID:             data.Violation.ID,
						Description:    data.Violation.Description,
						AIDescription:  data.Violation.AIDescription,
						Status:         data.Violation.Status,
						Severity:       data.Violation.Severity,
						Confidence:     data.Violation.Confidence,
						InspectorNotes: data.Violation.InspectorNotes,
						ThumbnailURL:   data.Violation.ThumbnailURL,
						OriginalURL:    data.Violation.OriginalURL,
						ImageID:        data.Violation.ImageID,
						Regulations:    violationRegsToQueueRegs(data.Violation.Regulations),
					},
					Position:   data.Position,
					TotalCount: data.TotalCount,
					HasPrev:    data.Position > 0,
					HasNext:    data.Position < data.TotalCount-1,
				}).Render(ctx, templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err != nil {
					return templ_7745c5c3_Err
				}
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 6, "</div></div> ")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = queueKeyboardScript(data.Inspection.ID).Render(ctx, templ_7745c5c3_Buffer)
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			return nil
		})
		templ_7745c5c3_Err = layouts.AppLayout(layouts.AppLayoutData{
			Title:       fmt.Sprintf("Review Violations - %s", data.Inspection.Title),
			CurrentPath: data.CurrentPath,
			User:        userToLayoutUser(data.User),
			CSRFToken:   data.CSRFToken,
			Flash:       data.Flash,
		}).Render(templ.WithChildren(ctx, templ_7745c5c3_Var2), templ_7745c5c3_Buffer)
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

// queueKeyboardScript provides the Alpine.js component for keyboard shortcuts.
// It triggers htmx buttons programmatically rather than managing state.
func queueKeyboardScript(inspectionID string) templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var3 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var3 == nil {
			templ_7745c5c3_Var3 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 7, "<script>\n\t\tconst queueInspectionID = @templ.Raw(fmt.Sprintf(\"%q\", inspectionID));\n\n\t\tfunction queueKeyboard() {\n\t\t\treturn {\n\t\t\t\thandleKeydown(e) {\n\t\t\t\t\t// Don't handle if in input field (let the edit form handle its own keys)\n\t\t\t\t\tif (['INPUT', 'TEXTAREA', 'SELECT'].includes(e.target.tagName)) {\n\t\t\t\t\t\t// Allow Escape to cancel edit\n\t\t\t\t\t\tif (e.key === 'Escape') {\n\t\t\t\t\t\t\t// Alpine's x-on:keydown.escape on the edit form will handle this\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Don't handle with modifier keys\n\t\t\t\t\tif (e.metaKey || e.ctrlKey || e.altKey) return;\n\n\t\t\t\t\tswitch (e.key.toLowerCase()) {\n\t\t\t\t\t\tcase 'a':\n\t\t\t\t\t\t\t// Accept - click the accept button\n\t\t\t\t\t\t\tconst acceptBtn = document.getElementById('btn-accept');\n\t\t\t\t\t\t\tif (acceptBtn && !acceptBtn.disabled) {\n\t\t\t\t\t\t\t\tacceptBtn.click();\n\t\t\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'r':\n\t\t\t\t\t\t\t// Reject - click the reject button\n\t\t\t\t\t\t\tconst rejectBtn = document.getElementById('btn-reject');\n\t\t\t\t\t\t\tif (rejectBtn && !rejectBtn.disabled) {\n\t\t\t\t\t\t\t\trejectBtn.click();\n\t\t\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'e':\n\t\t\t\t\t\t\t// Edit - trigger Alpine edit mode\n\t\t\t\t\t\t\t// The edit toggle is handled by Alpine within the partial\n\t\t\t\t\t\t\t// We need to dispatch a custom event or find another way\n\t\t\t\t\t\t\t// For now, we'll find and click any edit button\n\t\t\t\t\t\t\tconst editBtnContainer = document.querySelector('[x-show=\"!editing\"]');\n\t\t\t\t\t\t\tif (editBtnContainer) {\n\t\t\t\t\t\t\t\tconst editBtn = editBtnContainer.querySelector('button[\\\\@click*=\"editing\"]');\n\t\t\t\t\t\t\t\tif (editBtn) {\n\t\t\t\t\t\t\t\t\teditBtn.click();\n\t\t\t\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'j':\n\t\t\t\t\t\tcase 'arrowright':\n\t\t\t\t\t\t\t// Next - click the next button\n\t\t\t\t\t\t\tconst nextBtn = document.getElementById('btn-next');\n\t\t\t\t\t\t\tif (nextBtn && !nextBtn.disabled) {\n\t\t\t\t\t\t\t\tnextBtn.click();\n\t\t\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'k':\n\t\t\t\t\t\tcase 'arrowleft':\n\t\t\t\t\t\t\t// Previous - click the prev button\n\t\t\t\t\t\t\tconst prevBtn = document.getElementById('btn-prev');\n\t\t\t\t\t\t\tif (prevBtn && !prevBtn.disabled) {\n\t\t\t\t\t\t\t\tprevBtn.click();\n\t\t\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'escape':\n\t\t\t\t\t\t\t// Exit to inspection page\n\t\t\t\t\t\t\twindow.location.href = '/inspections/' + queueInspectionID;\n\t\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t</script>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

// Helper function to convert violation regulations to queue format
// This is defined in Go since templ templates can call Go functions
func violationRegsToQueueRegs(regs []ViolationRegulationDisplay) []partials.QueueRegulationDisplay {
	result := make([]partials.QueueRegulationDisplay, len(regs))
	for i, r := range regs {
		result[i] = partials.QueueRegulationDisplay{
			RegulationID:   r.RegulationID,
			StandardNumber: r.StandardNumber,
			Title:          r.Title,
			IsPrimary:      r.IsPrimary,
		}
	}
	return result
}

var _ = templruntime.GeneratedTemplate
